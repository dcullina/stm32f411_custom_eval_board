#![no_main]
#![no_std]
#![feature(type_alias_impl_trait)]
#![allow(unused_imports)]
#![allow(unsafe_code)]

use core::{ptr::addr_of_mut, slice, str};
use defmt_rtt as _;
use mpu6050::*;
use panic_probe as _;
use stm32f4xx_hal::{
    gpio::alt::otg_fs::{Dm, Dp},
    gpio::{gpioa, gpiob, Alternate, Edge, Input, Output, PushPull},
    i2c::I2c,
    otg_fs::{UsbBus, UsbBusType, USB},
    pac::{syscfg, I2C1, TIM5},
    prelude::*,
    timer::{self, Event},
};
use usb_device::{bus::UsbBusAllocator, prelude::*, test_class::SERIAL_NUMBER, UsbError};
use usbd_serial::{SerialPort, USB_CLASS_CDC};
static mut EP_MEMORY: [u32; 1024] = [0; 1024];

#[entry]
fn main() -> ! {
    // const SYSCLK: u32 = 100_000_000;
    const SYSCLK: u32 = 24_000_000;

    let mut dp = ctx.device;

    let rcc = dp.RCC.constrain();
    let clocks = rcc
        .cfgr
        .use_hse(24.MHz())
        .sysclk(SYSCLK.Hz())
        .require_pll48clk()
        .freeze();

    let mut syscfg = dp.SYSCFG.constrain();

    let gpiob = dp.GPIOB.split();

    let mut delay = dp.TIM5.delay_us(&clocks);

    let mut imu = gpiob.pb8.into_pull_up_input();
    imu.make_interrupt_source(&mut syscfg);
    imu.enable_interrupt(&mut dp.EXTI);
    imu.trigger_on_edge(&mut dp.EXTI, Edge::Rising);

    let gpioa = dp.GPIOA.split();

    static mut USB_BUS: Option<usb_device::bus::UsbBusAllocator<UsbBusType>> = None;

    let usb: USB = USB {
        usb_global: dp.OTG_FS_GLOBAL,
        usb_device: dp.OTG_FS_DEVICE,
        usb_pwrclk: dp.OTG_FS_PWRCLK,
        pin_dm: stm32f4xx_hal::gpio::alt::otg_fs::Dm::PA11(gpioa.pa11.into_alternate()),
        pin_dp: stm32f4xx_hal::gpio::alt::otg_fs::Dp::PA12(gpioa.pa12.into_alternate()),
        hclk: clocks.hclk(),
    };
    unsafe {
        USB_BUS.replace(UsbBus::new(usb, &mut EP_MEMORY));
    }

    let mut serial = usbd_serial::SerialPort::new(unsafe { USB_BUS.as_ref().unwrap() });

    let descriptors = StringDescriptors::new(LangID::EN)
        .manufacturer("fakeLLC")
        .product("test_pcb")
        .serial_number("12345");
    let mut usb_dev = UsbDeviceBuilder::new(
        unsafe { USB_BUS.as_ref().unwrap() },
        UsbVidPid(0x5740, 0x0483),
    )
    .strings(&[descriptors])
    .expect("could not build descriptors")
    .device_class(USB_CLASS_CDC)
    .build();

    // Initialize i2c connection
    let i2c: I2c<I2C1> = I2c::new(dp.I2C1, (gpiob.pb6, gpiob.pb7), 100.kHz(), &clocks);
    let mut mpu: Mpu6050<I2c<I2C1>> = Mpu6050::new(i2c);
    delay.delay_ms(1); // give mpu6050 time to initialize otherwise board will hang
    mpu.init(&mut delay).unwrap();

    let mut led = gpiob.pb13.into_push_pull_output();
    led.set_high();
    delay.delay_ms(1000);
    led.set_low();
    delay.delay_ms(1000);
    led.set_high();
    delay.delay_ms(1000);
    led.set_low();
    delay.delay_ms(1000);
    led.set_high();

    loop {
        defmt::info!("BEEP");
        led.set_high();
        delay.delay_ms(2000);
        led.set_low();
        delay.delay_ms(2000);

        match serial.write(&[0x3a, 0x29]) {
            Ok(_) => defmt::info!("Message sent!"),
            Err(UsbError::WouldBlock) => defmt::error!("no data written, buffers full"),
            Err(_) => defmt::error!("error occurred"),
        }
    }
}
